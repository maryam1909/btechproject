// Contract utility functions and constants
import { ethers } from 'ethers';

// Prefer ABI/address generated by deployment script; fallback to minimal ABI and empty address
let CONTRACT_ABI = [];
let CONTRACT_ADDRESS = "0x0000000000000000000000000000000000000000";

try {
  // These files are written by scripts/deployAmoy.js
  // Paths are relative to src/utils -> src/contracts
  // eslint-disable-next-line import/no-webpack-loader-syntax
  // eslint-disable-next-line global-require
  const addressJson = require('../contracts/contract-address.json');
  CONTRACT_ADDRESS = addressJson.address || CONTRACT_ADDRESS;
} catch (_) {}

try {
  // eslint-disable-next-line global-require
  const abiJson = require('../contracts/PharmaNFT.json');
  CONTRACT_ABI = abiJson.abi || CONTRACT_ABI;
} catch (_) {
  // Minimal fallback ABI for local dev if ABI file not yet generated
  CONTRACT_ABI = [
    "function mintBatch(string tokenURI, string batchID)",
    "function transferBatch(uint256 tokenId, address newOwner)",
    "function verifyBatch(uint256 tokenId) returns (bool)",
    "function getBatchDetails(uint256 tokenId) view returns (tuple(uint256 tokenId, address currentOwner, uint8 currentRole, string batchID, string metadataURI, string qrCodeURI, uint256 timestamp, address manufacturer))",
    "function getTransferHistory(uint256 tokenId) view returns (tuple(address from, address to, uint256 timestamp, uint8 fromRole, uint8 toRole)[])",
    "function getRole(address user) view returns (uint8)",
    "function tokenCounter() view returns (uint256)",
    "function ownerOf(uint256 tokenId) view returns (address)",
    "function registerManufacturer(address _manufacturer)",
    "function setRole(address user, uint8 role)",
    "function linkChildBatch(uint256 parentId, uint256 childId)",
    "function getChildBatches(uint256 parentId) view returns (uint256[])",
    "function getParentBatch(uint256 childId) view returns (uint256)",
    "function isManufacturer(address _manufacturer) view returns (bool)"
  ];
}

export { CONTRACT_ABI, CONTRACT_ADDRESS };

// Role constants
export const ROLES = {
  NONE: 0,
  MANUFACTURER: 1,
  DISTRIBUTOR: 2,
  RETAILER: 3,
  PHARMACY: 4
};

// Role names for display
export const ROLE_NAMES = {
  [ROLES.NONE]: 'None',
  [ROLES.MANUFACTURER]: 'Manufacturer',
  [ROLES.DISTRIBUTOR]: 'Distributor',
  [ROLES.RETAILER]: 'Retailer',
  [ROLES.PHARMACY]: 'Pharmacy'
};

// Role CSS classes
export const ROLE_CLASSES = {
  [ROLES.NONE]: '',
  [ROLES.MANUFACTURER]: 'role-manufacturer',
  [ROLES.DISTRIBUTOR]: 'role-distributor',
  [ROLES.RETAILER]: 'role-retailer',
  [ROLES.PHARMACY]: 'role-pharmacy'
};

// Contract utility functions
export class ContractUtils {
  constructor(contract, signer) {
    this.contract = contract;
    this.signer = signer;
  }

  // Get user role
  async getUserRole(address) {
    try {
      const role = await this.contract.getRole(address);
      return Number(role);
    } catch (error) {
      console.error('Error getting user role:', error);
      return ROLES.NONE;
    }
  }

  // Check if user is manufacturer
  async isManufacturer(address) {
    try {
      return await this.contract.isManufacturer(address);
    } catch (error) {
      console.error('Error checking manufacturer status:', error);
      return false;
    }
  }

  // Get batch details
  async getBatchDetails(tokenId) {
    try {
      return await this.contract.getBatchDetails(tokenId);
    } catch (error) {
      console.error('Error getting batch details:', error);
      throw error;
    }
  }

  // Get transfer history
  async getTransferHistory(tokenId) {
    try {
      return await this.contract.getTransferHistory(tokenId);
    } catch (error) {
      console.error('Error getting transfer history:', error);
      return [];
    }
  }

  // Get user's batches
  async getUserBatches(userAddress) {
    try {
      const tokenCounter = await this.contract.tokenCounter();
      const batches = [];
      
      for (let i = 1; i < Number(tokenCounter); i++) {
        try {
          const owner = await this.contract.ownerOf(i);
          if (owner.toLowerCase() === userAddress.toLowerCase()) {
            const batchDetails = await this.contract.getBatchDetails(i);
            batches.push({
              tokenId: i,
              ...batchDetails
            });
          }
        } catch (error) {
          // Token doesn't exist
        }
      }
      
      return batches;
    } catch (error) {
      console.error('Error getting user batches:', error);
      return [];
    }
  }

  // Validate address
  isValidAddress(address) {
    return ethers.isAddress(address);
  }

  // Format address for display
  formatAddress(address) {
    if (!address) return '';
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  }

  // Get role name
  getRoleName(role) {
    return ROLE_NAMES[role] || 'Unknown';
  }

  // Get role class
  getRoleClass(role) {
    return ROLE_CLASSES[role] || '';
  }

  // Check if transfer is valid
  isValidTransfer(currentRole, nextRole) {
    return (
      (currentRole === ROLES.MANUFACTURER && nextRole === ROLES.DISTRIBUTOR) ||
      (currentRole === ROLES.DISTRIBUTOR && nextRole === ROLES.RETAILER) ||
      (currentRole === ROLES.RETAILER && nextRole === ROLES.PHARMACY)
    );
  }

  // Get next role in sequence
  getNextRole(currentRole) {
    switch (currentRole) {
      case ROLES.MANUFACTURER: return ROLES.DISTRIBUTOR;
      case ROLES.DISTRIBUTOR: return ROLES.RETAILER;
      case ROLES.RETAILER: return ROLES.PHARMACY;
      default: return null;
    }
  }
}

// Event listeners for contract events
export const ContractEvents = {
  BatchMinted: 'BatchMinted',
  OwnershipTransferred: 'OwnershipTransferred',
  BatchVerified: 'BatchVerified',
  ManufacturerRegistered: 'ManufacturerRegistered',
  ChildBatchLinked: 'ChildBatchLinked'
};

// Helper function to create contract instance
export const createContract = (address, abi, signer) => {
  return new ethers.Contract(address, abi, signer);
};

// Helper function to get contract from provider
export const getContract = async (address, abi, provider) => {
  const signer = await provider.getSigner();
  return createContract(address, abi, signer);
};
